type Amenity {
  id: ID!

  name: String!

  provider: String

  category: String!

  unitId: ID

  createdAt: Time

  updatedAt: Time
}

type AnyUpload {
  id: ID!

  upload: String!

  category: String!

  propertyId: ID

  userId: ID

  unitId: ID

  createdAt: Time

  updatedAt: Time
}

type Bedroom {
  id: ID!

  propertyUnitId: ID!

  bedroomNumber: Int!

  enSuite: Boolean!

  master: Boolean!

  createdAt: Time

  updatedAt: Time
}

type Caretaker {
  id: ID!

  first_name: String!

  last_name: String!

  phone: String!

  uploads: [AnyUpload!]!

  verified: Boolean!

  properties: [Property!]!

  createdAt: Time

  updatedAt: Time
}

input CaretakerInput {
  first_name: String!

  last_name: String!

  phone: String!

  image: Upload!
}

input CaretakerVerificationInput {
  phone: String!

  verifyCode: String!
}

enum CountryCode {
  KE
}

input CreatePaymentInput {
  phone: String!

  amount: String!
}

type Gps {
  lat: Float!

  lng: Float!
}

input GpsInput {
  lat: Float!

  lng: Float!
}

input HandshakeInput {
  phone: String!
}

type Invoice {
  id: ID!

  msid: String!

  phone: String!

  status: InvoiceStatus!

  wCoCheckoutId: String!

  createdAt: Time

  updatedAt: Time
}

enum InvoiceStatus {
  PROCESSED

  PROCESSING
}

type ListingOverview {
  occupiedUnits: Int!

  vacantUnits: Int!

  totalUnits: Int!
}

type Mutation {
  signIn(input: NewUser!): SignInResponse!

  createProperty(input: NewProperty!): Property!

  addPropertyUnit(input: PropertyUnitInput!): PropertyUnit!

  addPropertyUnitTenant(input: TenancyInput!): Tenant!

  uploadImage(file: Upload!): String!

  sendVerificationCode(input: VerificationInput!): Status!

  verifyUserVerificationCode(input: UserVerificationInput!): Status!

  verifyCaretakerVerificationCode(input: CaretakerVerificationInput!): Status!

  handshake(input: HandshakeInput!): User!

  saveMailing(email: String): Status!

  createPayment(input: CreatePaymentInput!): Status!
}

input NewProperty {
  name: String!

  type: String!

  location: GpsInput!

  thumbnail: String!
}

input NewUser {
  phone: String!
}

type Property {
  id: ID!

  name: String!

  type: PropertyType!

  location: Gps!

  uploads: [AnyUpload!]!

  units: [PropertyUnit!]!

  createdBy: ID!

  caretaker: Caretaker!

  caretakerId: ID!

  owner: User!

  createdAt: Time

  updatedAt: Time
}

enum PropertyType {
  APARTMENTS_BUILDING

  APARTMENT
}

type PropertyUnit {
  id: ID!

  name: String!

  bedrooms: [Bedroom!]!

  propertyId: ID!

  property: Property!

  price: String!

  amenityCount: Int!

  bathrooms: Int!

  amenities: [Amenity!]!

  state: UnitState!

  type: String!

  uploads: [AnyUpload!]!

  tenancy: [Tenant!]!

  createdAt: Time

  updatedAt: Time
}

input PropertyUnitInput {
  propertyId: ID!

  baths: Int!

  name: String!

  location: GpsInput!

  type: String!

  amenities: [UnitAmenityInput!]!

  bedrooms: [UnitBedroomInput!]!

  price: String!

  uploads: [UploadImages!]
}

type Query {
  getUser(email: String!): User!

  getProperty(id: ID!): Property!

  hello: String!

  searchTown(town: String!): [Town!]!

  getTowns: [Town!]!

  getPropertyUnits(propertyId: ID!): [PropertyUnit!]!

  getPropertyTenancy(propertyId: ID!): [Tenant!]!

  getUserProperties: [Property!]!

  listingOverview(propertyId: ID!): ListingOverview!

  getListings: [Property!]!
}

type Shoot {
  id: ID!

  propertyId: String!

  date: Time!

  status: String!

  createdAt: Time

  updatedAt: Time
}

input ShootInput {
  date: Time!
}

enum ShootStatus {
  PENDING

  DONE
}

type SignInResponse {
  user: User!

  Token: String!
}

type Status {
  success: String!
}

input TenancyInput {
  startDate: Time!

  propertyUnitId: ID!
}

type Tenant {
  id: ID!

  startDate: Time!

  endDate: Time

  upload: [AnyUpload!]!

  propertyUnitId: ID!

  createdAt: Time

  updatedAt: Time
}

scalar Time

type Token {
  token: String!
}

type Town {
  id: ID!

  town: String!

  postalCode: String!
}

input UnitAmenityInput {
  name: String!

  category: String!
}

input UnitBedroomInput {
  bedroomNumber: Int!

  enSuite: Boolean!

  master: Boolean!
}

enum UnitState {
  VACANT

  OCCUPIED

  UNAVAILABLE
}

scalar Upload

enum UploadCategory {
  PROFILE_IMG

  UNIT_IMAGE

  CARETAKER_IMG
}

input UploadImages {
  image: String!

  category: String!
}

type User {
  id: ID!

  email: String!

  first_name: String!

  last_name: String!

  phone: String!

  is_landlord: Boolean!

  uploads: [AnyUpload!]!

  onboarding: Boolean!

  properties: [Property!]!

  createdAt: Time

  updatedAt: Time
}

input UserVerificationInput {
  phone: String!

  verifyCode: String!
}

input VerificationInput {
  phone: String!

  verifyCode: String
}

# See https://github.com/JetBrains/js-graphql-intellij-plugin/issues/665
# noinspection GraphQLTypeRedefinition
"""
The @deprecated built-in directive is used within the type system definition language to indicate deprecated portions of a GraphQL service's schema, such as deprecated fields on a type, arguments on a field, input fields on an input type, or values of an enum type.
"""
directive @deprecated (reason: String = "No longer supported") on FIELD_DEFINITION|ARGUMENT_DEFINITION|INPUT_FIELD_DEFINITION|ENUM_VALUE

# See https://github.com/JetBrains/js-graphql-intellij-plugin/issues/665
# noinspection GraphQLTypeRedefinition
"""
The @include directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional inclusion during execution as described by the if argument.
"""
directive @include (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

# See https://github.com/JetBrains/js-graphql-intellij-plugin/issues/665
# noinspection GraphQLTypeRedefinition
"""
The @skip directive may be provided for fields, fragment spreads, and inline fragments, and allows for conditional exclusion during execution as described by the if argument.
"""
directive @skip (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

# See https://github.com/JetBrains/js-graphql-intellij-plugin/issues/665
# noinspection GraphQLTypeRedefinition
"""
The @specifiedBy built-in directive is used within the type system definition language to provide a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy (url: String!) on SCALAR

schema {
  query: Query
  mutation: Mutation
}
